

/*
 * Classic example grammar, which recognizes simple arithmetic expressions like
 * "2*(3+4)". The parser generated from this grammar then computes their value.
 */

/*
 * DCPU16 ASM Parser
 */

{
  var line = 1;
  var tmp;
  var i;
}

start
  = program:statements
    {
      return program;
    }


statements
  = nl* stmt:stmt statements:statements
    { return [stmt].concat(statements); }

  / stmt:stmt
    { return [stmt]; }

  / nl*
    { return []; }


stmt
  = ws "#macro"? ws name:label ws "(" ws params:paramlist ws ")" ws nl? "{" ws nl? code:statements ws "}" ws
    {
      return {
        name: name,
        params: params,
        src: code,
        action: "macro"
      };
    }

  / ws name:label ws "(" ws params:paramlist ws ")"
    {
      return {
        line: line,
        name: name,
        params: params,
        action: "macrocall"
      };
    }

  / ws d:directive ws params:wsparamlist ws
    {
      return {
        line: line,
        directive: d,
        params: params,
        action: "directive"
      };
    }

  / ws label:labeldef? ws cmd:cmd ws
    {
      tmp = {
        line: line,
        cmd: cmd,
        action: "op"
      };
      if (label.length > 0) {
        tmp.label = label;
      }
      return tmp;
    }

  / ws label:labeldef ws
    {
      return {
        line: line,
        label: label,
        action: "op"
      };
    }

  / comment
    {
      return {
        action: "nop"
      };
    }


cmd
  = ws op:op ws plist:paramlist
    {
      return {
        op: op,
        params: plist
      };
    }

op "operator"
  = op:([a-zA-Z][a-zA-Z][a-zA-Z]) { return op.join('').toUpperCase(); }

paramlist
  = label:labeldef? ws v:param ws "," ws l:paramlist
    {
      if (label.length > 0) {
        v.label = label;
      }
      return [v].concat(l);
    }
  / label:labeldef? ws v:param
    {
      if (label.length > 0) {
        v.label = label;
      }
      return [v];
    }

wsparamlist
  = label:labeldef? ws v:param ws ","? ws l:paramlist
    {
      if (label.length > 0) {
        v.label = label;
      }
      return [v].concat(l);
    }
  / label:labeldef? ws v:param
    {
      if (label.length > 0) {
        v.label = label;
      }
      return [v];
    }

param "parameter"
  = "[" ws m:"--"? ws "SP" ws p:"++"? ws "]"
    {
      tmp = "PEEK";
      if (m === '--' && p === '') {
        tmp = "PUSH";
      } else if (m === '' && p === '++') {
        tmp = "POP";
      }

      return {
        isString: true,
        value: tmp
      };
    }
  / "[" v:additive "]"
    {
      v.hasBrackets = true;
      return v;
    }
  / v:additive
    {
      return v;
    }

additive
  = left:multiplicative ws right:(("+" / "-") ws multiplicative ws)*
    {
      tmp = {
        isExpression: true,
        op: "add",
        ops: [],
        children: [left]
      };
      
      for (i = 0; i < right.length; i++) {
        tmp.ops.push(right[i][0]);
        tmp.children.push(right[i][2]);
      }

      if (right.length === 0) {
        tmp = left;
      }

      return tmp;
    }

multiplicative
  = left:value ws right:(("*" / "/") ws value ws)*
    {
      tmp = {
        isExpression: true,
        op: 'mul',
        ops: [],
        children: [left]
      };

      for (i = 0; i < right.length; i++) {
        tmp.ops.push(right[i][0]);
        tmp.children.push(right[i][2]);
      }

      if (right.length === 0) {
        tmp = left;
      }

      return tmp;
    }

value
  = v:number
    {
      return {
        value: v,
        isNumber: true
      };
    }
  / v:label
    {
      return {
        value: v,
        isString: true
      };
    }
  / "\"" v:strliteral "\""
    {
      return {
        value: v,
        isStringLiteral: true
      };
    }
  / "(" ws v:additive ws ")"
    { return v; }


number "number"
  /* oct */
  = v:("0"[0-9]+)
    { return parseInt(v[0] + v[1].join(''), 8); }
  /* hex */
  / v:("0x"[0-9a-fA-F]+)
    { return parseInt(v[0] + v[1].join(''), 16); }
  /* dec */
  / v:[0-9]+
    { return parseInt(v.join(''), 10); }

strliteral "stringliteral"
  = v:allbutquotes*
    { return v.join(''); }

labeldef
  = ":" l:label
    { return l; }

label "label"
  = label:([a-zA-Z0-9_\.]+)
    {
      return label.join('');
    }

directive "directive"
  = ("." / "#") l:label
    { return l; }

allbutquotes
  = v:"\\\""
    { return "\""; }
  / v:[^\"]
    { return v; }

comment
  = ";" [^\n\r]*

ws "whitespace"
  = " "*

nl "newline"
  = "\n" ws { line++; }
  / "\r\n" ws { line++; }
  / "\r" ws { line++; }

