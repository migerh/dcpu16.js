<html>
	<head>
		<script type="text/javascript" src="src/dcpu16.js"></script>
		<script type="text/javascript" src="src/base64.js"></script>
		<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/ace/0.2.0/ace.js"></script>
		
		<style type="text/css">
			.markline {
				position: absolute;
				background: pink;
				z-index: 5;
			}
		</style>
	</head>
<body>
<!--p>
	<a href="javascript:void(0);" onclick="load('example-1');">Ref example</a>
	<a href="javascript:void(0);" onclick="load('example-screen');">Screen buffer example</a>
	<a href="javascript:void(0);" onclick="load('example-breaking');">Example that breaks in some emulators</a>
</p-->
<span style="font-size: 11px;">Click the line numbers to toggle breakpoints. Drop asm source files or rom files over the editor to load them. Click &quot;Assemble&quot; after you made changes to the source.</span>
<p>
	<div id="src" style="width: 800px; height: 400px; float: left;"></div>
	<pre id="status" style="margin-left: 810px; width: 200px; height: 400px;"></pre>
</p>
<p>
	<button onclick="asm();">Assemble</button>
	<button onclick="step();">Step</button>
	<button onclick="start();">Start</button>
	<button onclick="stop();">Stop</button>
	<button onclick="downloadRom();">Download rom</button>
</p>

<button onclick="gotoRam();">Go to</button> <input type="text" value="0" id="jumpto" />
<button onclick="gotoRam('SP');" onmouseover="highlightRam('SP');" onmousemove="highlightRam('SP');" onmouseout="highlightRam('none');">SP</button>
<button onclick="gotoRam('PC');" onmouseover="highlightRam('PC');" onmousemove="highlightRam('PC');" onmouseout="highlightRam('none');">PC</button><br />
<pre id="ram" style="margin-top: 0; width: 400px; height: 170px; font-size: 14px; overflow-x: hidden; overflow-y: scrollbar; float: left;"></pre>
<div id="out" style="margin-left: 410px; width: 400px; height: 170px; background-color: black; border: 1px solid black;"></div>

<script type="text/javascript">
	var PC, assembly, editor, marker,
		Range = require("ace/range").Range,
		
		load = function (what) {
			editor.getSession().setValue($('#' + what).html());
		},
		markLine = function (line) {
			range = new Range(line-1, 0, line, 0);
			editor.getSession().removeMarker(marker);
			marker = editor.getSession().addMarker(range, "markline", "line");
			editor.gotoLine(line);
		},
		newPC = function () {
			PC = new DCPU16.PC(assembly.bc);
			PC.on('update', printStatus, this);
			printStatus();
		},
		asm = function () {
			var src = editor.getSession().getValue(),
				bc = DCPU16.asm(src);

			assembly = bc;

			newPC();			
		},
		step = function () {
			PC.step();
		},
		start = function () {
			PC.start();
		},
		stop = function () {
			PC.stop();
		},
		printValue = function (v) {
			var r = v.toString(16),
				i, l = 4;
			
			for (i = r.length; i < l; i++) {
				r = '0' + r;
			}
				
			return r;
		},
		printStatus = function () {
			var out = [];
			
			markLine(assembly.meta.addr2line[PC.ram.PC]);
			out.push('A  = ' + printValue(PC.ram.A) + '    ');
			out.push('B  = ' + printValue(PC.ram.B) + '<br />');
			out.push('C  = ' + printValue(PC.ram.C) + '    ');
			out.push('X  = ' + printValue(PC.ram.X) + '<br />');
			out.push('Y  = ' + printValue(PC.ram.Y) + '    ');
			out.push('Z  = ' + printValue(PC.ram.Z) + '<br />');
			out.push('I  = ' + printValue(PC.ram.I) + '    ');
			out.push('J  = ' + printValue(PC.ram.J) + '<br /><br />');

			out.push('PC = ' + printValue(PC.ram.PC) + '    ');
			out.push('SP = ' + printValue(PC.ram.SP) + '<br />');
			out.push('O  = ' + printValue(PC.ram.O) + '<br /><br />');
			out.push('Stack: <br />');
			if (PC.ram.SP > 0xFF00) {
				for (i = PC.ram.SP; i < 0x10000; i++ ) {
					out.push('[' + printValue(PC.getWord(i)) + ']<br />');
				}
			}
			
			$('#status').html(out.join(''));
			$('#out').html(PC.screen2html());
			
			gotoRam();
		},
		printRam = function (offset) {
			var i, ram = [];
			for (i = 0; i < 80; i++) {
				if (i%8 === 0) {
					ram.push((i !== 0 ? '</span>\n' : '') + '<span id="ram-line-' + ((offset + i)/8) + '" class="ram-line">' + printValue(offset + i) + '  ');
				}
				
				ram.push('<span id="ram-word-' + (offset + i) + '" class="ram-word">' + printValue(PC.getWord(offset + i)) + '</span>');
			}
			$('#ram').html(ram.join(' '));
		},
		gotoRam = function (where) {
			if (where) {
				where = PC.ram[where];
			} else {
				where = DCPU16._.parseInt($('#jumpto').val());
			}
			where = Math.min(Math.floor(where/8), 0xffb0/8),
			
			printRam(where*8);
		},
		highlightRam = function (where) {
			$('.ram-word').css('background-color', 'white');
			
			if (where == 'none') {
				return;
			}
			
			if (where) {
				where = PC.ram[where];
			} else {
				where = DCPU16._.parseInt($('#jumpto').val());
			}
			
			$('#ram-word-' + where).css('background-color', 'pink');
		},
		downloadRom = function () {
			window.open('data:application/octet-stream;base64,' + Base64.encode(assembly.bc), '_blank', 'height=300,width=400');
		};
	
	window.onload = function () {
		editor = ace.edit("src");
		
		$('#src > div.ace_gutter').on('click', function (e) {
			var line = $(e.toElement),
				lineNumber = line.html().match(/\d*$/);
			
			if (assembly.meta.line2addr[lineNumber]) {
				line.html((PC.toggleBreakpoint(assembly.meta.line2addr[lineNumber]) ? '<span style="color: red; font-weight: bolder;">&bull;</span> ' : '') + lineNumber);
			}
		});
		
		$('#src > .ace_sb').on('scroll', function (e) {
			$('#src div.ace_gutter-cell').each(function (i, line) {
				var lineNumber = $(line).html().match(/\d*$/),
					lineAddr = assembly.meta.line2addr[lineNumber];
					
				if (PC.breakpoints[lineAddr]) {
					$(line).html('<span style="color: red; font-weight: bolder;">&bull;</span> ' + lineNumber);
				}
			});
		});
		
		document.addEventListener('dragover', function (e) {
			e.stopPropagation();
			e.preventDefault();
			
			e.dataTransfer.dropEffect = 'none';
		}, false);
		
		document.getElementById('src').addEventListener('dragover', function (e) {
			e.stopPropagation();
			e.preventDefault();
			
			e.dataTransfer.dropEffect = 'copy';
		}, false);
		
        document.getElementById('src').addEventListener('drop', function (e) {
			var files = e.dataTransfer.files, f,
				firstTry,
				reader = new FileReader();

			e.stopPropagation();
			e.preventDefault();

			if (files.length > 0) {
                f = files[0];
                
				reader.onloadend = function (result) {
					var i, rom = [];
					
					if (firstTry) {
						if (firstTry == result.target.result) {
						console.log('found src');
							editor.getSession().setValue(firstTry);
							asm();
						} else {
						console.log('found rom');
							for (i = 0; i < firstTry.length; i++) {
								rom.push(firstTry.charCodeAt(i));
							}
							assembly = DCPU16.dasm(rom);
							editor.getSession().setValue(assembly.src);
							newPC();
						}
					} else {
						firstTry = result.target.result;
						reader.readAsText(f);
					}
				};
				
				reader.onerror = function (result) {
					alert('Error while reading file.');
				};
				reader.readAsBinaryString(f);
			}
        }, false);
		
		load('example-screen');
		asm();
	};
</script>

<!-- examples -->

		<script type="text/dcpu-asm" id="example-1">
		        ; Try some basic stuff
                      set A, 0x30              ; 7c01 0030
                      SET [0x1000], 0x20       ; 7de1 1000 0020
                      SUB a, [0x1000]          ; 7803 1000
                      IfN A, 0x10              ; c00d 
                         SET Pc, crash         ; 7dc1 001a [*]
                      
        ; Do a loopy thing
                      SET I, 10                ; a861
                      SET A, 0x2000            ; 7c01 2000
        :loop
                 SET [0x2000+I], [A]      ; 2161 2000
                      SUB I, 1                 ; 8463
                      IFN I, 0                 ; 806d
                         SET PC, loop          ; 7dc1 000d [*]
        
        ; Call a subroutine
                      SET X, 0x4               ; 9031
                      JSR testsub              ; 7c10 0018 [*]
                      SET PC, crash            ; 7dc1 001a [*]
        
        :testsub      SHL X, 4                 ; 9037
                      SET PC, POP              ; 61c1
                        
        ; Hang forever. X should now be 0x40 if everything went right.
        :crash        SET PC, crash            ; 7dc1 001a [*]
        
        :data
        			dat 0x170, "Hello, World!", 0x65, 73, "w0,,0t!"
        
        ; [*]: Note that these can be one word shorter and one cycle faster by using the short form (0x00-0x1f) of literals,
        ;      but my assembler doesn't support short form labels yet.
		</script>
		<script type="text/dcpu-asm" id="example-screen">
:start
	set i, 0
	set j, 0
	set b, 0xf100

:nextchar
	set a, (data+i)
	ife a, 0
		set PC, end
	ifg a, 0xff
		set PC, setcolor
	bor a, b
	set (0x8000+j), a
	add i, 1
	add j, 1
	set PC, nextchar

:setcolor
	set b, a
	and b, 0xff
	shl b, 8
	ifg a, 0x1ff
		add b, 0x80
	add i, 1
	set PC, nextchar

:data
	dat 0x170, "Hello ", 0x2e1, "world", 0x170, ", how are you?", 0x0

:end
	set PC, start
		</script>
		<script type="text/dcpu-asm" id="example-breaking">
set PUSH, mod_colorshift
set PUSH, mod_hello
set [task_list], SP
set PUSH, 2
:sched_task_run
    set A, [task_list]
    add A, [task]
    set PC, [A]
:sched_advance
    add [task], 1
    set A, [task_list]
    sub A, 1 ; Get task count in A
    ife [A], [task]
        set [task], 0
    set PC, sched_task_run
:yield
    set X, POP ; Get task PC
    set A, [task_list]
    add A, [task]
    set [A], X ; Overwrite task slot with current pc
    set PC, sched_advance
; System Variables
:task
dat 0
:task_list
dat 0
:putc_line
dat 0
:putc_col
dat 0
:newline
dat "\n"
:putc_color
dat 0xf100

; Terminal Subroutines
; Put char in reg A to screen
:putc
    set PUSH, B
    ife A, [newline]
        set PC, putc_newline
    bor A, [putc_color]
    set B, [putc_line]
    mul B, 32
    add B, [putc_col]
    add B, 0x8000
    set [B], A
    add [putc_col], 1
    ifg 32, [putc_col]
        set PC, putc_end
:putc_newline
    add [putc_line], 1
    set [putc_col], 0
    ifg 16, [putc_line]
        set PC, putc_end
    ; We need to scroll!
    jsr scroll
    set [putc_line], 16
:putc_end
    set B, POP
    set PC, POP ; return
    ; Scroll the terminal up one line
    ; Each line is 32 words
:scroll
    set PUSH, I ; Index in video ram
    set PUSH, A ; Index of thing we're copying
    set I, 0x8000
:scroll_loop
    set A, I
    add A, 32 ; Corresponding character on next line
    ifg A, 0x8400 ; End of video ram
        set PC, scroll_end ; return
    set [I], [A] ; Copy back 32 words
    add I, 1
    set PC, scroll_loop
:scroll_end
    set A, POP
    set I, POP
    set PC, POP ; return
:mod_colorshift
add [putc_color], 0x100
jsr yield
SET PC, mod_colorshift
:mod_hello
set [mod_hello_itr], 0
:mod_hello_loop
set I, [mod_hello_itr]
add I, mod_hello_hwstr
set A, [I]
ife A, 0
    set PC, mod_hello_end
jsr putc
add [mod_hello_itr], 1
set PC, mod_hello_loop
:mod_hello_end
jsr yield
set PC, mod_hello
:mod_hello_hwstr
    dat "Hey everybody, how is it going in DCPU16 land today?\n", 0x0
:mod_hello_itr
    dat 0
		</script>
		
</body>
</html>
